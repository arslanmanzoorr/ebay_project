// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model User {
  id           String    @id
  name         String
  email        String    @unique
  password     String
  role         String    @default("user") // 'researcher' | 'photographer' | 'researcher2' | 'admin' | 'super_admin'
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @default(now()) @updatedAt @map("updated_at")
  isActive     Boolean   @default(true) @map("is_active")
  createdBy    String?   @map("created_by")

  // Relations
  createdUsers      User[]    @relation("CreatedUsers")
  creator           User?     @relation("CreatedUsers", fields: [createdBy], references: [id])

  assignedItems     AuctionItem[] @relation("AssignedItems")
  adminItems        AuctionItem[] @relation("AdminItems")
  transactions      CreditTransaction[]
  notifications     Notification[]
  credits           UserCredit?
  updatedSettings   CreditSetting[]

  @@map("users")
  @@index([createdBy])
}

model AuctionItem {
  id                   String   @id
  url                  String?
  urlMain              String?  @map("url_main")
  auctionName          String?  @map("auction_name")
  lotNumber            String?  @map("lot_number")
  images               String[]
  mainImageUrl         String?  @map("main_image_url")
  sku                  String?
  itemName             String?  @map("item_name")
  category             String?
  description          String?
  lead                 String?
  auctionSiteEstimate  String?  @map("auction_site_estimate")
  aiDescription        String?  @map("ai_description")
  aiEstimate           String?  @map("ai_estimate")
  status               String
  researcherEstimate   String?  @map("researcher_estimate")
  researcherDescription String? @map("researcher_description")
  referenceUrls        String[] @map("reference_urls")
  similarUrls          String[] @map("similar_urls")
  photographerQuantity Int?     @map("photographer_quantity")
  photographerImages   String[] @map("photographer_images")
  isMultipleItems      Boolean  @default(false) @map("is_multiple_items")
  multipleItemsCount   Int      @default(1) @map("multiple_items_count")
  finalData            Json?    @map("final_data") // JSONB
  createdAt            DateTime @default(now()) @map("created_at")
  updatedAt            DateTime @default(now()) @updatedAt @map("updated_at")
  assignedTo           String?  @map("assigned_to")
  notes                String?
  photographerNotes    String?  @map("photographer_notes")
  researcherNotes      String?  @map("researcher_notes")
  researcher2Notes     String?  @map("researcher2_notes")
  priority             String?  @default("medium")
  tags                 String[]
  parentItemId         String?  @map("parent_item_id")
  subItemNumber        Int?     @map("sub_item_number")
  adminId              String?  @map("admin_id")

  // Relations
  assignedUser  User? @relation("AssignedItems", fields: [assignedTo], references: [id]) // Assuming assignedTo uses Name or ID? logic in code uses string, usually ID in foreign keys. Need to verify if assigned_to is ID or Name. database.ts doesn't explicitly FK it but usually it is. database.ts: assigned_to VARCHAR(255). existing code seems to use it as ID or Name. Let's assume ID for now or keep loose.
  // Actually database.ts does NOT have a FOREIGN KEY on assigned_toUrl.
  // But let's check: "FOREIGN KEY (admin_id) REFERENCES users(id)" is there.
  // "FOREIGN KEY (parent_item_id) REFERENCES auction_items(id)" is there.

  admin         User? @relation("AdminItems", fields: [adminId], references: [id])
  parentItem    AuctionItem?   @relation("SubItems", fields: [parentItemId], references: [id])
  subItems      AuctionItem[]  @relation("SubItems")

  workflowSteps WorkflowStep[]
  notifications Notification[]

  @@map("auction_items")
}

// NOTE: assigned_to in database.ts does NOT have a foreign key constraint.
// Only admin_id has a FK constraint to users(id).
// I will keep assignedUser relation optional and mapped, assuming it stores User ID. If it stores name, this will fail at runtime if I try to use relation.
// Looking at types/auction.ts: assignedTo?: string; -> logic might just store a string.
// Use caution with `assignedUser` relation.

model WorkflowStep {
  id         String   @id
  itemId     String   @map("item_id")
  fromStatus String   @map("from_status")
  toStatus   String   @map("to_status")
  userId     String   @map("user_id")
  userName   String   @map("user_name")
  timestamp  DateTime @default(now())
  notes      String?
  data       Json?

  item       AuctionItem @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@map("workflow_steps")
}

model Notification {
  id        String   @id
  userId    String   @map("user_id")
  type      String
  title     String
  message   String
  read      Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at")
  itemId    String?  @map("item_id")

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  item      AuctionItem? @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model WebhookData {
  id                 String   @id
  urlMain            String   @map("url_main")
  itemName           String?  @map("item_name")
  lotNumber          String?  @map("lot_number")
  description        String?
  lead               String?
  category           String?
  estimate           String?
  auctionName        String?  @map("auction_name")
  allUniqueImageUrls String[] @map("all_unique_image_urls")
  mainImageUrl       String?  @map("main_image_url")
  galleryImageUrls   String[] @map("gallery_image_urls")
  broadSearchImages  String[] @map("broad_search_images")
  thumbnailImages    String[] @map("thumbnail_images")
  aiResponse         String?  @map("ai_response")
  receivedAt         DateTime @default(now()) @map("received_at")
  status             String?  @default("processed")

  @@map("webhook_data")
}

model UserCredit {
  id             String   @id
  userId         String   @unique @map("user_id")
  currentCredits Int      @default(60) @map("current_credits")
  totalPurchased Int      @default(60) @map("total_purchased")
  lastTopupDate  DateTime? @map("last_topup_date")
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @default(now()) @updatedAt @map("updated_at")

  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_credits")
  @@index([userId])
}

model CreditTransaction {
  id              String   @id
  userId          String   @map("user_id")
  transactionType String   @map("transaction_type")
  amount          Int
  description     String?
  createdAt       DateTime @default(now()) @map("created_at")

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("credit_transactions")
  @@index([userId])
  @@index([transactionType])
}

model CreditSetting {
  id           String   @id
  settingName  String   @unique @map("setting_name")
  settingValue Int      @map("setting_value")
  description  String?
  updatedBy    String?  @map("updated_by")
  updatedAt    DateTime @default(now()) @map("updated_at")

  updater      User?    @relation(fields: [updatedBy], references: [id])

  @@map("credit_settings")
  @@index([settingName])
}
